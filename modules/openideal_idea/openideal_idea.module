<?php

/**
 * @file
 * Contains openideal_idea.module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\node\NodeInterface;

/**
 * Implements hook_form_alter().
 */
function openideal_idea_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_id == 'node_idea_form') {
    // Check challenge query parameter.
    if ($challenge_id = \Drupal::request()->get('challenge')) {
      // Load predefined challenge node.
      $predefined_challenge = \Drupal::entityTypeManager()
        ->getStorage('node')
        ->load($challenge_id);
      if (!empty($predefined_challenge)) {
        // Set predefined challenge to the idea node form element.
        $form['field_challenge']['widget'][0]['target_id']['#default_value'] = $predefined_challenge;
      }
    }

    // Rename draft_approval state as Publish.
    if (isset($form['moderation_state']['widget'][0]['state']['#options']['draft_approval'])) {
      $form['moderation_state']['widget'][0]['state']['#options']['draft_approval'] = t('Publish');
    }
  }

  // Unset useless group roles for group idea membership add form.
  if ($form_id == 'group_content_idea-group_membership_add_form') {
    // @TODO: add condition by user role.
    unset($form['group_roles']['widget']['#options']['idea-author']);
    unset($form['group_roles']['widget']['#options']['idea-expert']);
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function openideal_idea_node_presave(EntityInterface $entity) {
  // Add status message for idea with draft or draft_approval state.
  if (
    $entity->bundle() == 'idea' &&
    in_array($entity->get('moderation_state')->value, ['draft', 'draft_approval'])
  ) {
    $openideal_config = config_pages_config('openideal_configurations');
    $message = $openideal_config->field_idea_approval_message->view('default');
    if (!empty($message)) {
      \Drupal::messenger()->addMessage($message);
    }
  }

  // Check entity type and duplicate_of field of the entity.
  if (
    $entity->bundle() == 'idea' &&
    !$entity->get('field_duplicate_of')->isEmpty()
  ) {
    // Set 'merged' value for idea_phase field of the entity.
    $entity->field_idea_phase->target_id = 5;
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function openideal_idea_node_insert(EntityInterface $entity) {
  if ($entity->bundle() == 'idea') {
    try {
      // Create the group for the node.
      /** @var \Drupal\group\Entity\Group $group */
      $group = \Drupal::entityTypeManager()->getStorage('group')
        ->create([
          'label' => $entity->label(),
          'type' => 'idea',
          'langcode' => 'en',
        ]);
      $group->save();
      // Define the plugin id.
      $plugin_id = 'group_node:' . $entity->bundle();
      // Add the entity to the group.
      $group->addContent($entity, $plugin_id);
    }
    catch (\Exception $e) {
      \Drupal::logger('openideal_idea')->error($e->getMessage());
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_predelete().
 */
function openideal_idea_node_predelete(EntityInterface $entity) {
  if ($entity->bundle() == 'idea') {
    // Delete the group that contains this node.
    if ($group = _openideal_idea_get_group_by_entity($entity)) {
      $group->delete();
    }
  }
}

/**
 * Implements hook_entity_access().
 */
function openideal_idea_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {
  if ($entity->getEntityTypeId() === 'comment') {
    $commented_entity = $entity->getCommentedEntity();
    if ($commented_entity->bundle() === 'idea' && $operation === 'update') {
      return AccessResult::forbiddenIf(!$commented_entity->get('field_duplicate_of')->isEmpty());
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_create_access().
 */
function openideal_idea_comment_create_access(AccountInterface $account, array $context, $entity_bundle) {
  /** @var \Drupal\node\NodeInterface $node */
  $node = \Drupal::routeMatch()->getParameter('node');
  if ($node instanceof NodeInterface && $node->bundle() === 'idea') {
    return AccessResult::forbiddenIf(!$node->get('field_duplicate_of')->isEmpty());
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function openideal_idea_menu_local_tasks_alter(&$data, $route_name, RefinableCacheableDependencyInterface &$cacheability) {
  if ($route_name !== 'entity.node.canonical') {
    return;
  }

  $node = \Drupal::routeMatch()->getParameter('node');
  if ($node->bundle() === 'idea' && $group = _openideal_idea_get_group_by_entity($node)) {
    $data['tabs'][0]['group.members'] = [
      '#theme' => 'menu_local_task',
      '#link' => [
        'title' => t('Group Members'),
        'url' => Url::fromRoute('view.group_members.page_1', ['group' => $group->id()]),
      ],
      '#access' => $group->hasPermission('administer members', \Drupal::currentUser()),
    ];

    // The tab we're adding is dependent on a user's access to add content.
    $cacheability->addCacheContexts(['user.group_permissions']);
  }
}

/**
 * Get single group entity that represents a given entity.
 *
 * @param object $entity
 *   Entity instance.
 *
 * @return \Drupal\group\Entity\GroupInterface|null
 *   Group entity or NULL.
 */
function _openideal_idea_get_group_by_entity($entity) {
  // In our case we will have one node per group.
  // We get all group ids but return just the first one.
  $group_contents = \Drupal::entityTypeManager()
    ->getStorage('group_content')
    ->loadByEntity($entity);
  foreach ($group_contents as $group_content) {
    $groups[] = $group_content->getGroup();
  }

  return !empty($groups) ? array_shift($groups) : NULL;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function openideal_idea_form_views_exposed_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form['#id'] != 'views-exposed-form-ideas-all-ideas-page') {
    return;
  }
  // Remove workflow title form the views exposed filter.
  // @see https://www.drupal.org/project/drupal/issues/3091182
  if (isset($form['phase']['#options']['Life Cycle Phases'])) {
    foreach ($form['phase']['#options']['Life Cycle Phases'] as $key => $phase_option) {
      $form['phase']['#options'][$key] = $phase_option;
    }
    unset($form['phase']['#options']['Life Cycle Phases']);
  }
  // Get the list of published and opened challenges.
  $node_storage = \Drupal::entityTypeManager()->getStorage('node');
  $query = $node_storage->getQuery()
    ->condition('type', 'challenge', '=')
    ->condition('field_is_open', TRUE, '=')
    ->condition('status', NodeInterface::PUBLISHED)
    ->latestRevision()
    ->sort('title');
  $nids = $query->execute();

  if (empty($nids)) {
    $form['challenge']['#access'] = FALSE;
    return;
  }

  /** @var \Drupal\node\NodeInterface $node */
  $options = [];
  foreach ($node_storage->loadMultiple($nids) as $node) {
    $options[$node->id()] = $node->getTitle();
  }
  // Replace existing challenge form element with select.
  $form['challenge'] = [
    '#type' => 'select',
    '#multiple' => FALSE,
    '#empty_option' => t("Any"),
    '#options' => $options,
  ];
}
